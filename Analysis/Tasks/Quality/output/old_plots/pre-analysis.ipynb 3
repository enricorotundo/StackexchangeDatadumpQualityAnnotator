{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "NOTE: to run notebook use: venv/bin/python manage.py shell_plus --notebook\n",
    "\"\"\"\n",
    "\n",
    "import django\n",
    "django.setup()\n",
    "\n",
    "import os\n",
    "from django.conf import settings\n",
    "from DatasetAnnotator.models import Posts\n",
    "from django.db.models import Q, F\n",
    "from django.db.models import Count, Sum, Max, Avg\n",
    "from django.db.models import When, Case, Value\n",
    "from django.db.models import IntegerField, FloatField\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from django.db.models.functions import Greatest, Coalesce\n",
    "\n",
    "%matplotlib inline\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "sns.set(style=\"white\", palette=\"muted\", color_codes=True)\n",
    "available_dbs = settings.DATABASES.keys()[1:]\n",
    "PLOTS_PATH = 'Analysis/plots/'\n",
    "PLOTS_FORMATS = ['.pdf', '.png']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Threads length (all data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "# example: {'cooking':[1,2,1,2,5], 'webapps': [...] ....}\n",
    "threads_length = dict()\n",
    "\n",
    "for db in available_dbs:\n",
    "    os.write(1, db+\"\\n\")\n",
    "    \n",
    "        \n",
    "    # STAGE 1: considering (only) actual threads (later must sum 1 for the question)\n",
    "    threads_length[db] = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=2)\\\n",
    "        .values('parentid')\\\n",
    "        .annotate(thread_len_part=Count('parentid'))\\\n",
    "        .values_list('thread_len_part', flat=True)\n",
    "    # adding 1 to count the question\n",
    "    threads_length[db] = [x+1 for x in threads_length[db]]\n",
    "    \n",
    "    \n",
    "    # STAGE 2: considering (only) unanswered questions\n",
    "    # get ids of questions with answers\n",
    "    parent_questions_ids = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=2)\\\n",
    "        .values_list('parentid', flat=True)\\\n",
    "        .distinct()\n",
    "    # count unanswered questions\n",
    "    unanswered_q_count = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=1)\\\n",
    "        .exclude(id__in=parent_questions_ids)\\\n",
    "        .count()\n",
    "    \n",
    "    # append unanswered q to total counting\n",
    "    threads_length[db] = threads_length[db] + [1 for i in range(unanswered_q_count)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Thread length VS Nr threads (all data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "# for each distinct value in [...] count its occurence, zip the result\n",
    "\n",
    "t_length_count = dict()\n",
    "\n",
    "for db in available_dbs:    \n",
    "    # count occurences\n",
    "    bins = np.bincount(threads_length[db])\n",
    "    # remove zeros from bins\n",
    "    t_count = bins[np.nonzero(bins)]\n",
    "    # sorted threads sizes\n",
    "    t_sizes = np.unique(threads_length[db])\n",
    "    \n",
    "    t_length_count[db] = {\n",
    "        't_count': t_count,\n",
    "        't_sizes': t_sizes\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize=(6,6))\n",
    "ax1 = fig.add_subplot(111)\n",
    "\n",
    "ax1.scatter(x=t_length_count['cooking']['t_sizes'], \n",
    "            y=t_length_count['cooking']['t_count'], \n",
    "            label='cooking', s=50, c='b', marker='x', clip_on=False)\n",
    "ax1.scatter(x=t_length_count['travel']['t_sizes'], \n",
    "            y=t_length_count['travel']['t_count'], \n",
    "            label='travel', s=50, c='r', marker='o', clip_on=False)\n",
    "ax1.scatter(x=t_length_count['webapps']['t_sizes'], \n",
    "            y=t_length_count['webapps']['t_count'], \n",
    "            label='webapps', s=50, c='g', marker='*', clip_on=False)\n",
    "\n",
    "ax1.set_xscale('log', nonposx='clip')\n",
    "ax1.set_yscale('log', nonposy='clip')\n",
    "plt.xlabel('thread size (num answers)', fontsize=18)\n",
    "plt.ylabel('count', fontsize=18)\n",
    "plt.title('Thread sizes (all data)', fontsize=18)\n",
    "ax1.set_xlim(xmin=0.9)\n",
    "xmin, xmax = ax1.get_xlim()\n",
    "ymin, ymax = ax1.get_ylim()\n",
    "\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "plt.legend()\n",
    "plt.tight_layout()\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'thread_sizes_ALL' + plot_format)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Thread length VS Nr threads (annotated data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "# example: {'cooking':[1,2,1,2,5], 'webapps': [...] ....}\n",
    "threads_length = dict()\n",
    "\n",
    "for db in available_dbs:\n",
    "    os.write(1, db+\"\\n\")\n",
    "    \n",
    "        \n",
    "    # STAGE 1: considering (only) actual threads (later must sum 1 for the question)\n",
    "    \n",
    "    # note: assumes question and all posts have been annotated (doesn't count answers not annotated)\n",
    "    threads_length[db] = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=2)\\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "        .values('parentid')\\\n",
    "        .annotate(thread_len_part=Count('parentid'))\\\n",
    "        .values_list('thread_len_part', flat=True)\n",
    "    # adding 1 to count the question\n",
    "    threads_length[db] = [x+1 for x in threads_length[db]]\n",
    "    \n",
    "    \n",
    "    # STAGE 2: considering (only) unanswered questions\n",
    "    \n",
    "    # get ids of questions with answers\n",
    "    parent_questions_ids = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=2)\\\n",
    "        .values_list('parentid', flat=True)\\\n",
    "        .distinct()\n",
    "    # count unanswered questions\n",
    "    unanswered_q_count = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=1)\\\n",
    "        .exclude(id__in=parent_questions_ids)\\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "        .count()\n",
    "    \n",
    "    # append unanswered q to total counting\n",
    "    threads_length[db] = threads_length[db] + [1 for i in range(unanswered_q_count)]\n",
    "    \n",
    "    \n",
    "    \n",
    "# for each distinct value in [...] count its occurence, zip the result\n",
    "\n",
    "t_length_count = dict()\n",
    "\n",
    "for db in available_dbs:    \n",
    "    # count occurences\n",
    "    bins = np.bincount(threads_length[db])\n",
    "    # remove zeros from bins\n",
    "    t_count = bins[np.nonzero(bins)]\n",
    "    # sorted threads sizes\n",
    "    t_sizes = np.unique(threads_length[db])\n",
    "    \n",
    "    t_length_count[db] = {\n",
    "        't_count': t_count,\n",
    "        't_sizes': t_sizes\n",
    "    }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize=(6,6))\n",
    "ax1 = fig.add_subplot(111)\n",
    "\n",
    "ax1.scatter(x=t_length_count['cooking']['t_sizes'], \n",
    "            y=t_length_count['cooking']['t_count'], \n",
    "            label='cooking', s=50, c='b', marker='x', clip_on=False)\n",
    "ax1.scatter(x=t_length_count['travel']['t_sizes'], \n",
    "            y=t_length_count['travel']['t_count'], \n",
    "            label='travel', s=50, c='r', marker='o', clip_on=False)\n",
    "ax1.scatter(x=t_length_count['webapps']['t_sizes'], \n",
    "            y=t_length_count['webapps']['t_count'], \n",
    "            label='webapps', s=50, c='g', marker='*', clip_on=False)\n",
    "\n",
    "\n",
    "ax1.set_xscale('log', nonposx='clip')\n",
    "ax1.set_yscale('log', nonposy='clip')\n",
    "plt.xlabel('thread size (num answers)', fontsize=18)\n",
    "plt.ylabel('count', fontsize=18)\n",
    "plt.title('Thread sizes (annotated data)', fontsize=18)\n",
    "ax1.set_xlim(xmin=xmin, xmax=xmax)\n",
    "ax1.set_ylim(ymin=ymin, ymax=ymax)\n",
    "\n",
    "\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "plt.legend()\n",
    "plt.tight_layout()\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'thread_sizes_ANNOTATED' + plot_format)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Quality distribution VS Threads length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "def mean_custon(q_q, a_q, thread_size):\n",
    "    if (q_q is None and a_q is None):\n",
    "        return None\n",
    "    elif (q_q is None and a_q is not None):\n",
    "        return q_q\n",
    "    elif (q_q is not None and a_q is None):\n",
    "        return a_q / float(thread_size)\n",
    "    elif (q_q is not None and a_q is not None):\n",
    "        return (q_q + a_q) / float(thread_size)\n",
    "    \n",
    "\n",
    "#  \n",
    "\"\"\"\n",
    "example: {'cooking':\n",
    "            question_id: {\n",
    "                    'thread_size: 4,\n",
    "                    'thread_avg_quality: 1.3\n",
    "                }\n",
    "#         }\n",
    "\"\"\"\n",
    "threads_data = {\n",
    "    'cooking': {},\n",
    "    'webapps': {},\n",
    "    'travel': {}\n",
    "}\n",
    "\n",
    "\n",
    "for db in available_dbs:\n",
    "    #print db\n",
    "        \n",
    "    # STAGE 1: considering (only) actual threads\n",
    "    \n",
    "    questions = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=1)\\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) |\n",
    "                Q(annotatedqualitymarit__isnull=False) |\n",
    "                Q(annotatedqualitychristine__isnull=False) |\n",
    "                Q(annotatedqualityhenrik__isnull=False))\\\n",
    "        .values('id', \n",
    "                'answercount', \n",
    "                'annotatedqualityenrico')\n",
    "       \n",
    "    answers = Posts.objects\\\n",
    "        .using(db)\\\n",
    "        .filter(posttypeid=2)\\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) |\n",
    "                Q(annotatedqualitymarit__isnull=False) |\n",
    "                Q(annotatedqualitychristine__isnull=False) |\n",
    "                Q(annotatedqualityhenrik__isnull=False))\\\n",
    "        .values('parentid')\\\n",
    "        .annotate(sum_qual_enrico=Sum('annotatedqualityenrico'))\n",
    "    \n",
    "    for question in questions:\n",
    "        threads_data[db][int(question['id'])] = {\n",
    "            'thread_size': question['answercount'] + 1,\n",
    "            'thread_avg_quality': question['annotatedqualityenrico']\n",
    "        }\n",
    "    \n",
    "    for answer in answers:\n",
    "        question_quality = threads_data[db][int(answer['parentid'])]['thread_avg_quality']\n",
    "        thread_size = threads_data[db][int(answer['parentid'])]['thread_size']\n",
    "        actual_average = mean_custon(question_quality, answer['sum_qual_enrico'], thread_size)\n",
    "        threads_data[db][int(answer['parentid'])]['thread_avg_quality'] = actual_average\n",
    "        \n",
    "    #print threads_data[db]\n",
    "    \n",
    "    \n",
    "    \n",
    "# for each distinct value in [...] count its occurence, zip the result\n",
    "\"\"\"\n",
    "example:        {\n",
    "                    'webapps': {\n",
    "                        't_sizes': array([2,    3,  4,  5,  8]), \n",
    "                        't_count': array([29,   12, 7,  1,  1])\n",
    "                        }, {...}\n",
    "                }\n",
    "\"\"\"\n",
    "t_length_count = {}\n",
    "\n",
    "for db in available_dbs:\n",
    "    #print db\n",
    "    t_lengths_list = [value['thread_size'] for key, value in threads_data[db].iteritems()]\n",
    "    \n",
    "    # count occurences\n",
    "    bins = np.bincount(t_lengths_list)\n",
    "    # remove zeros from bins\n",
    "    t_count = bins[np.nonzero(bins)]\n",
    "    # sorted threads sizes\n",
    "    t_sizes = np.unique(threads_length[db])\n",
    "    \n",
    "    t_length_count[db] = {\n",
    "        't_count': t_count,\n",
    "        't_sizes': t_sizes,\n",
    "        't_avg_qual': []\n",
    "    }\n",
    "    \n",
    "    for size in t_sizes:\n",
    "        avg_thread_sizes = []\n",
    "        for key, value in threads_data[db].iteritems():\n",
    "            if value['thread_size'] == size:\n",
    "                avg_thread_sizes.append(value['thread_avg_quality'])\n",
    "        t_length_count[db]['t_avg_qual'].append(avg_thread_sizes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "print t_length_count['cooking']\n",
    "# http://matplotlib.org/examples/pylab_examples/boxplot_demo2.html"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Annotations distribution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "annotations_dist = dict()\n",
    "\n",
    "for db in available_dbs:    \n",
    "    # note: no need to remove -99 as at least one annotation is in [-1,0,1,2]\n",
    "    annotations_dist[db] = Posts.objects.using(db) \\\n",
    "                            .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                                Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                                Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                                Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "                            .annotate(max=Greatest(\n",
    "                                    Coalesce('annotatedqualityenrico', -99), \n",
    "                                    Coalesce('annotatedqualitymarit', -99),\n",
    "                                    Coalesce('annotatedqualitychristine', -99),\n",
    "                                    Coalesce('annotatedqualityhenrik', -99)))\\\n",
    "                            .values_list('max', flat=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "bins = 10\n",
    "opacity = 1\n",
    "\n",
    "plt.figure(figsize=(12,5))\n",
    "plt.suptitle('Annotations distribution (-1=Dontknow, 0=Low, 1=Mid, 2=High)', fontsize=18)\n",
    "\n",
    "ax = plt.subplot(131)\n",
    "plt.hist(annotations_dist['cooking'], bins=bins, alpha=opacity, color='b', label='cooking')\n",
    "plt.xlabel('Annotation', fontsize=18)\n",
    "plt.ylabel('Count', fontsize=18)\n",
    "plt.title('cooking', fontsize=18)\n",
    "\n",
    "plt.subplot(132)\n",
    "plt.hist(annotations_dist['travel'], bins=bins, alpha=opacity, color='r', label='travel')\n",
    "plt.xlabel('Annotation', fontsize=18)\n",
    "#plt.ylabel('Count', fontsize=18)\n",
    "plt.title('travel', fontsize=18)\n",
    "\n",
    "plt.subplot(133)\n",
    "plt.hist(annotations_dist['webapps'], bins=bins, alpha=opacity, color='g', label='webapps')\n",
    "plt.xlabel('Annotation', fontsize=18)\n",
    "#plt.ylabel('Count', fontsize=18)\n",
    "plt.title('webapps', fontsize=18)\n",
    "\n",
    "plt.tight_layout(pad=3)\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'annotations_dist' + plot_format)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Counting of questions/answers, per db"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "items_counting = {\n",
    "    'whole_data': {\n",
    "        'cooking': {\n",
    "            'questions': -1,\n",
    "            'answers': -1,\n",
    "            'other': -1\n",
    "        },\n",
    "        'webapps': {\n",
    "            'questions': -1,\n",
    "            'answers': -1,\n",
    "            'other': -1\n",
    "        },\n",
    "        'travel': {\n",
    "            'questions': -1,\n",
    "            'answers': -1,\n",
    "            'other': -1\n",
    "        }\n",
    "    },\n",
    "    'annotated_data': {\n",
    "        'cooking': {\n",
    "            'questions': -1,\n",
    "            'answers': -1,\n",
    "            'other': -1\n",
    "        },\n",
    "        'webapps': {\n",
    "            'questions': -1,\n",
    "            'answers': -1,\n",
    "            'other': -1\n",
    "        },\n",
    "        'travel': {\n",
    "            'questions': -1,\n",
    "            'answers': -1,\n",
    "            'other': -1\n",
    "        }\n",
    "    }\n",
    "}\n",
    "\n",
    "for db in available_dbs:\n",
    "    # total nr of questions\n",
    "    items_counting['whole_data'][db]['questions'] = \\\n",
    "        Posts.objects \\\n",
    "            .using(db) \\\n",
    "            .filter(posttypeid=1) \\\n",
    "            .count()\n",
    "\n",
    "    # Total nr. of answers\n",
    "    items_counting['whole_data'][db]['answers'] = \\\n",
    "        Posts.objects \\\n",
    "            .using(db) \\\n",
    "            .filter(posttypeid=2) \\\n",
    "            .count()\n",
    "\n",
    "    # Total nr. of other posts\n",
    "    items_counting['whole_data'][db]['other'] = \\\n",
    "        Posts.objects \\\n",
    "            .using(db) \\\n",
    "            .exclude(posttypeid=1) \\\n",
    "            .exclude(posttypeid=2) \\\n",
    "            .count()\n",
    "\n",
    "    # counting annotated questions\n",
    "    items_counting['annotated_data'][db]['questions'] = \\\n",
    "        Posts.objects.using(db) \\\n",
    "            .filter(posttypeid=1) \\\n",
    "            .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                    Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                    Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                    Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "            .count()\n",
    "\n",
    "    # counting annotated answers\n",
    "    items_counting['annotated_data'][db]['answers'] = \\\n",
    "        Posts.objects.using(db) \\\n",
    "            .filter(posttypeid=2) \\\n",
    "            .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                    Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                    Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                    Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "            .count()\n",
    "\n",
    "    # counting annotated others\n",
    "    items_counting['annotated_data'][db]['others'] = \\\n",
    "        Posts.objects.using(db) \\\n",
    "            .exclude(posttypeid=1) \\\n",
    "            .exclude(posttypeid=2) \\\n",
    "            .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                    Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                    Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                    Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "            .count()\n",
    "\n",
    "# whole_data\n",
    "questions_whole_d = [items_counting['whole_data'][db]['questions'] for db in available_dbs]\n",
    "answers_whole_d = [items_counting['whole_data'][db]['answers'] for db in available_dbs]\n",
    "other_whole_d = [items_counting['whole_data'][db]['other'] for db in available_dbs]\n",
    "\n",
    "# annotated_data\n",
    "questions_ann_d = [items_counting['annotated_data'][db]['questions'] for db in available_dbs]\n",
    "answers_ann_d = [items_counting['annotated_data'][db]['answers'] for db in available_dbs]\n",
    "other_ann_d = [items_counting['annotated_data'][db]['other'] for db in available_dbs]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "n_groups = 3\n",
    "bar_width = 0.25\n",
    "opacity = 1\n",
    "\n",
    "\n",
    "# whole_data\n",
    "plt.figure(figsize=(12,6))\n",
    "plt.suptitle('Questions/answers counting', fontsize=18)\n",
    "plt.subplot(121)\n",
    "index = np.arange(n_groups)\n",
    "\n",
    "plt.bar(index, questions_whole_d, bar_width, alpha=opacity, color='b', label='questions')\n",
    "plt.bar(index + bar_width, answers_whole_d, bar_width, alpha=opacity, color='r', label='answers')\n",
    "#plt.bar(index + bar_width*2, other_whole_d, bar_width, alpha=opacity, color='g', label='other')\n",
    "\n",
    "plt.xlabel('Dataset', fontsize=18)\n",
    "plt.ylabel('Count', fontsize=18)\n",
    "plt.title('All data', fontsize=18)\n",
    "plt.xticks(index + bar_width / 2, available_dbs)\n",
    "plt.legend()\n",
    "\n",
    "\n",
    "# annotated_data\n",
    "plt.subplot(122)\n",
    "index = np.arange(n_groups)\n",
    "\n",
    "plt.bar(index, questions_ann_d, bar_width, alpha=opacity, color='b', label='questions')\n",
    "plt.bar(index + bar_width, answers_ann_d, bar_width, alpha=opacity, color='r', label='answers')\n",
    "#plt.bar(index + bar_width*2, other_ann_d, bar_width, alpha=opacity, color='g', label='other')\n",
    "\n",
    "plt.xlabel('Dataset', fontsize=18)\n",
    "plt.ylabel('Count', fontsize=18)\n",
    "plt.title('Annotated data (only)', fontsize=18)\n",
    "plt.xticks(index + bar_width / 2, available_dbs)\n",
    "plt.legend()\n",
    "plt.tight_layout(pad=3)\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'QA_counting' + plot_format)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Nr answers and nr questions, per user (all data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "# note: ids are non-negative integers\n",
    "users_activity = {\n",
    "    'whole_data': {\n",
    "        'cooking': {\n",
    "            # '1': {\n",
    "            #     'nr_questions': -1,\n",
    "            #     'nr_answers': -1\n",
    "            # }   \n",
    "        },\n",
    "        'webapps': {},\n",
    "        'travel': {}\n",
    "    },\n",
    "    'annotated_data': {\n",
    "        'cooking': {},\n",
    "        'webapps': {},\n",
    "        'travel': {}\n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "for db in available_dbs:\n",
    "    \n",
    "    # whole_data\n",
    "    \n",
    "    # ex. [{'owneruserid': 17L, 'nr_questions': 13, 'nr_answers': 12}, {...}, {...}]\n",
    "    whole_d_vals = Posts.objects.using(db)\\\n",
    "        .order_by()\\\n",
    "        .values('owneruserid')\\\n",
    "        .distinct()\\\n",
    "        .annotate(\n",
    "            nr_questions=Sum(\n",
    "            Case(When(posttypeid=1, then=Value(1)),\n",
    "                 default=Value(0),\n",
    "                 output_field=IntegerField())),\n",
    "            nr_answers=Sum(\n",
    "            Case(When(posttypeid=2, then=Value(1)),\n",
    "                 default=Value(0),\n",
    "                 output_field=IntegerField()))\n",
    "        )\n",
    "    \n",
    "    data = dict()\n",
    "    for val in whole_d_vals:\n",
    "        # owneruserid == None if user has been deleted, -1 for wiki entries, see http://meta.stackexchange.com/questions/2677/database-schema-documentation-for-the-public-data-dump-and-sede\n",
    "        if val['owneruserid'] >= 1:\n",
    "            data[val['owneruserid']] = {'nr_questions': val['nr_questions'], 'nr_answers': val['nr_answers']}\n",
    "    users_activity['whole_data'][db] = data\n",
    "    \n",
    "    \n",
    "    # ONLY annotated_data\n",
    "    \n",
    "    # ex. [{'owneruserid': 17L, 'nr_questions': 13, 'nr_answers': 12}, {...}, {...}]\n",
    "    whole_d_vals = Posts.objects.using(db)\\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                    Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                    Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                    Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "        .order_by()\\\n",
    "        .values('owneruserid')\\\n",
    "        .distinct()\\\n",
    "        .annotate(\n",
    "            nr_questions=Sum(\n",
    "            Case(When(posttypeid=1, then=Value(1)),\n",
    "                 default=Value(0),\n",
    "                 output_field=IntegerField())),\n",
    "            nr_answers=Sum(\n",
    "            Case(When(posttypeid=2, then=Value(1)),\n",
    "                 default=Value(0),\n",
    "                 output_field=IntegerField()))\n",
    "        )\n",
    "    \n",
    "    data = dict()\n",
    "    for val in whole_d_vals:\n",
    "        # owneruserid == None if user has been deleted, -1 for wiki entries, see http://meta.stackexchange.com/questions/2677/database-schema-documentation-for-the-public-data-dump-and-sede\n",
    "        if val['owneruserid'] >= 1:\n",
    "            data[val['owneruserid']] = {'nr_questions': val['nr_questions'], 'nr_answers': val['nr_answers']}\n",
    "    users_activity['annotated_data'][db] = data\n",
    "    \n",
    "    \n",
    "# extract: each data point is a user, x is #questions, y is #answers\n",
    "\n",
    "# whole data\n",
    "whole_d_cooking = pd.DataFrame.from_dict(users_activity['whole_data']['cooking'], orient='index')\n",
    "whole_d_travel = pd.DataFrame.from_dict(users_activity['whole_data']['travel'], orient='index')\n",
    "whole_d_webapps = pd.DataFrame.from_dict(users_activity['whole_data']['webapps'], orient='index')\n",
    "# annotated data\n",
    "annotated_data_cooking = pd.DataFrame.from_dict(users_activity['annotated_data']['cooking'], orient='index')\n",
    "annotated_data_travel = pd.DataFrame.from_dict(users_activity['annotated_data']['travel'], orient='index')\n",
    "annotated_data_webapps = pd.DataFrame.from_dict(users_activity['annotated_data']['webapps'], orient='index')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "s=20\n",
    "\n",
    "# scatter plots\n",
    "\n",
    "fig = plt.figure(figsize=(15, 6))\n",
    "fig.suptitle(\"#answers vs #questions, per user (all data)\", fontsize=18)\n",
    "\n",
    "ax1 = fig.add_subplot(131)\n",
    "ax1.set_xscale('symlog', nonposx='clip')\n",
    "ax1.set_yscale('symlog', nonposx='clip')\n",
    "ax1.scatter(x=whole_d_cooking['nr_questions'], \n",
    "            y=whole_d_cooking['nr_answers'], \n",
    "            label='cooking', s=s, c='b', marker='x')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('Users activity', fontsize=18)\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "\n",
    "ax2 = fig.add_subplot(132, sharey=ax1, sharex=ax1)\n",
    "ax2.set_xscale('symlog', nonposx='clip')\n",
    "ax2.set_yscale('symlog', nonposy='clip')\n",
    "ax2.scatter(x=whole_d_travel['nr_questions'], \n",
    "            y=whole_d_travel['nr_answers'], \n",
    "            label='travel', s=s, c='r', marker='o')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "#plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('Users activity', fontsize=18)\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "\n",
    "ax3 = fig.add_subplot(133, sharey=ax1, sharex=ax1)\n",
    "ax3.set_xscale('symlog', nonposx='clip')\n",
    "ax3.set_yscale('symlog', nonposy='clip')\n",
    "ax3.scatter(x=whole_d_webapps['nr_questions'], \n",
    "            y=whole_d_webapps['nr_answers'], \n",
    "            label='webapps', s=s, c='g', marker='*')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "#plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('Users activity', fontsize=18)\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "\n",
    "plt.tight_layout(pad=3)\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'nr_answers_VS_nr_questions_scatter_ALL' + plot_format)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "# hex bins\n",
    "\n",
    "gridsize = 30\n",
    "\n",
    "fig = plt.figure(figsize=(15, 5))\n",
    "fig.suptitle(\"#answers vs #questions, per user (all data)\", fontsize=18)\n",
    "\n",
    "ax1 = fig.add_subplot(131, sharey=ax1, sharex=ax1)\n",
    "hb = ax1.hexbin(x=whole_d_cooking['nr_questions'].replace(0, 0.5), \n",
    "                y=whole_d_cooking['nr_answers'].replace(0, 0.5), \n",
    "                xscale='log', \n",
    "                yscale='log',\n",
    "                norm=matplotlib.colors.LogNorm(),\n",
    "                label='cooking',\n",
    "                cmap='cool',\n",
    "                gridsize=gridsize,\n",
    "                mincnt=1)\n",
    "#ax1.axis([0.5, whole_d_cooking['nr_questions'].max(), 0.5, whole_d_cooking['nr_answers'].max()])\n",
    "cb = fig.colorbar(hb, ax=ax1)\n",
    "cb.set_label('Nr users')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('cooking', fontsize=18)\n",
    "\n",
    "\n",
    "ax2 = fig.add_subplot(132,  sharey=ax1, sharex=ax1)\n",
    "hb = ax2.hexbin(x=whole_d_travel['nr_questions'].replace(0, 0.5), \n",
    "                y=whole_d_travel['nr_answers'].replace(0, 0.5), \n",
    "                xscale='log', \n",
    "                yscale='log',\n",
    "                norm=matplotlib.colors.LogNorm(),\n",
    "                label='travel',\n",
    "                cmap='cool',\n",
    "                gridsize=gridsize,\n",
    "                mincnt=1)\n",
    "#ax2.axis([0.5, whole_d_cooking['nr_questions'].max(), 0.5, whole_d_cooking['nr_answers'].max()])\n",
    "cb = fig.colorbar(hb, ax=ax2)\n",
    "cb.set_label('Nr users')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('travel', fontsize=18)\n",
    "\n",
    "\n",
    "ax3 = fig.add_subplot(133,  sharey=ax1, sharex=ax1)\n",
    "hb = ax3.hexbin(x=whole_d_webapps['nr_questions'].replace(0, 0.5), \n",
    "                y=whole_d_webapps['nr_answers'].replace(0, 0.5), \n",
    "                xscale='log', \n",
    "                yscale='log',\n",
    "                norm=matplotlib.colors.LogNorm(),\n",
    "                label='webapps',\n",
    "                cmap='cool',\n",
    "                gridsize=gridsize,\n",
    "                mincnt=1)\n",
    "#ax3.axis([0.5, whole_d_cooking['nr_questions'].max(), 0.5, whole_d_cooking['nr_answers'].max()])\n",
    "cb = fig.colorbar(hb, ax=ax3)\n",
    "cb.set_label('Nr users')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('webapps', fontsize=18)\n",
    "\n",
    "\n",
    "plt.tight_layout(pad=3)\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'nr_answers_VS_nr_questions_2dhist_ALL' + plot_format)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "s=20\n",
    "\n",
    "# scatter plots\n",
    "\n",
    "fig = plt.figure(figsize=(15, 6))\n",
    "fig.suptitle(\"#answers vs #questions, per user (annotated data)\", fontsize=18)\n",
    "\n",
    "ax1 = fig.add_subplot(131, sharey=ax1, sharex=ax1)\n",
    "ax1.set_xscale('symlog', nonposx='clip')\n",
    "ax1.set_yscale('symlog', nonposx='clip')\n",
    "ax1.scatter(x=annotated_data_cooking['nr_questions'], \n",
    "            y=annotated_data_cooking['nr_answers'], \n",
    "            label='cooking', s=s, c='b', marker='x')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('Users activity', fontsize=18)\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "\n",
    "ax2 = fig.add_subplot(132, sharey=ax1, sharex=ax1)\n",
    "ax2.set_xscale('symlog', nonposx='clip')\n",
    "ax2.set_yscale('symlog', nonposy='clip')\n",
    "ax2.scatter(x=annotated_data_travel['nr_questions'], \n",
    "            y=annotated_data_travel['nr_answers'], \n",
    "            label='travel', s=s, c='r', marker='o')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "#plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('Users activity', fontsize=18)\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "\n",
    "ax3 = fig.add_subplot(133, sharey=ax1, sharex=ax1)\n",
    "ax3.set_xscale('symlog', nonposx='clip')\n",
    "ax3.set_yscale('symlog', nonposy='clip')\n",
    "ax3.scatter(x=annotated_data_webapps['nr_questions'], \n",
    "            y=annotated_data_webapps['nr_answers'], \n",
    "            label='webapps', s=s, c='g', marker='*')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "#plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('Users activity', fontsize=18)\n",
    "plt.grid(alpha=0.7, linestyle='dotted')\n",
    "\n",
    "plt.tight_layout(pad=3)\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'nr_answers_VS_nr_questions_scatter_ANNOTATED' + plot_format)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "# hex bins\n",
    "\n",
    "gridsize=8\n",
    "\n",
    "fig = plt.figure(figsize=(15, 5))\n",
    "fig.suptitle(\"#answers vs #questions, per user (annotated data)\", fontsize=18)\n",
    "\n",
    "ax1 = fig.add_subplot(131, sharey=ax1, sharex=ax1)\n",
    "hb = ax1.hexbin(x=annotated_data_cooking['nr_questions'].replace(0, 0.5), \n",
    "                y=annotated_data_cooking['nr_answers'].replace(0, 0.5), \n",
    "                xscale='log', \n",
    "                yscale='log',\n",
    "                norm=matplotlib.colors.LogNorm(),\n",
    "                label='cooking',\n",
    "                cmap='cool',\n",
    "                gridsize=gridsize,\n",
    "                mincnt=1)\n",
    "#ax1.axis([0.5, whole_d_cooking['nr_questions'].max(), 0.5, whole_d_cooking['nr_answers'].max()])\n",
    "cb = fig.colorbar(hb, ax=ax1)\n",
    "cb.set_label('Nr users')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('cooking', fontsize=18)\n",
    "\n",
    "\n",
    "ax2 = fig.add_subplot(132,  sharey=ax1, sharex=ax1)\n",
    "hb = ax2.hexbin(x=annotated_data_travel['nr_questions'].replace(0, 0.5), \n",
    "                y=annotated_data_travel['nr_answers'].replace(0, 0.5), \n",
    "                xscale='log', \n",
    "                yscale='log',\n",
    "                norm=matplotlib.colors.LogNorm(),\n",
    "                label='travel',\n",
    "                cmap='cool',\n",
    "                gridsize=gridsize,\n",
    "                mincnt=1)\n",
    "#ax2.axis([0.5, whole_d_cooking['nr_questions'].max(), 0.5, whole_d_cooking['nr_answers'].max()])\n",
    "cb = fig.colorbar(hb, ax=ax2)\n",
    "cb.set_label('Nr users')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('travel', fontsize=18)\n",
    "\n",
    "\n",
    "ax3 = fig.add_subplot(133,  sharey=ax1, sharex=ax1)\n",
    "hb = ax3.hexbin(x=annotated_data_webapps['nr_questions'].replace(0, 0.5), \n",
    "                y=annotated_data_webapps['nr_answers'].replace(0, 0.5), \n",
    "                xscale='log', \n",
    "                yscale='log',\n",
    "                norm=matplotlib.colors.LogNorm(),\n",
    "                label='webapps',\n",
    "                cmap='cool',\n",
    "                gridsize=gridsize,\n",
    "                mincnt=1)\n",
    "#ax3.axis([0.5, whole_d_cooking['nr_questions'].max(), 0.5, whole_d_cooking['nr_answers'].max()])\n",
    "cb = fig.colorbar(hb, ax=ax3)\n",
    "cb.set_label('Nr users')\n",
    "plt.xlabel('Number of questions', fontsize=18)\n",
    "plt.ylabel('Number of answers', fontsize=18)\n",
    "plt.title('webapps', fontsize=18)\n",
    "\n",
    "\n",
    "plt.tight_layout(pad=3)\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'nr_answers_VS_nr_questions_2dhist_ANNOTATED' + plot_format)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "deletable": true,
    "editable": true
   },
   "source": [
    "# Question quality vs Answer quality"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "question_qual_vs_ans_qual = dict()\n",
    "\n",
    "for db in available_dbs:\n",
    "    \n",
    "    threads_quality = dict()\n",
    "    \n",
    "    questions_quality = Posts.objects.using(db) \\\n",
    "        .filter(posttypeid=1) \\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "        .values('id') \\\n",
    "        .annotate(question_quality=Greatest(\n",
    "        Coalesce('annotatedqualityenrico', -99),\n",
    "        Coalesce('annotatedqualitymarit', -99),\n",
    "        Coalesce('annotatedqualitychristine', -99),\n",
    "        Coalesce('annotatedqualityhenrik', -99)))\n",
    "\n",
    "    answers_quality = Posts.objects.using(db) \\\n",
    "        .filter(posttypeid=2) \\\n",
    "        .filter(Q(annotatedqualityenrico__isnull=False) | \\\n",
    "                Q(annotatedqualitymarit__isnull=False) | \\\n",
    "                Q(annotatedqualitychristine__isnull=False) | \\\n",
    "                Q(annotatedqualityhenrik__isnull=False)) \\\n",
    "        .values('parentid') \\\n",
    "        .annotate(nr_answers_high=Sum(\n",
    "            Case(\n",
    "                When(annotatedqualityenrico__exact=2, then=1),\n",
    "                When(annotatedqualitymarit__exact=2, then=1),\n",
    "                When(annotatedqualitychristine__exact=2, then=1),\n",
    "                When(annotatedqualityhenrik__exact=2, then=1),\n",
    "                default=0,\n",
    "                output_field=IntegerField())),\n",
    "            nr_answers_mid=Sum(\n",
    "            Case(\n",
    "                When(annotatedqualityenrico__exact=1, then=1),\n",
    "                When(annotatedqualitymarit__exact=1, then=1),\n",
    "                When(annotatedqualitychristine__exact=1, then=1),\n",
    "                When(annotatedqualityhenrik__exact=1, then=1),\n",
    "                default=0,\n",
    "                output_field=IntegerField())),\n",
    "            nr_answers_low=Sum(\n",
    "            Case(\n",
    "                When(annotatedqualityenrico__exact=0, then=1),\n",
    "                When(annotatedqualitymarit__exact=0, then=1),\n",
    "                When(annotatedqualitychristine__exact=0, then=1),\n",
    "                When(annotatedqualityhenrik__exact=0, then=1),\n",
    "                default=0,\n",
    "                output_field=IntegerField())),\n",
    "            nr_answers_unknow=Sum(\n",
    "            Case(\n",
    "                When(annotatedqualityenrico__exact=-1, then=1),\n",
    "                When(annotatedqualitymarit__exact=-1, then=1),\n",
    "                When(annotatedqualitychristine__exact=-1, then=1),\n",
    "                When(annotatedqualityhenrik__exact=-1, then=1),\n",
    "                default=0,\n",
    "                output_field=IntegerField()))\n",
    "            )\n",
    "    \n",
    "    for thread in questions_quality:\n",
    "        threads_quality[thread['id']] = {'question_quality': thread['question_quality']}\n",
    "    for thread in answers_quality:\n",
    "        threads_quality[thread['parentid']].update(\n",
    "            {\n",
    "                'nr_answers_high': thread['nr_answers_high'],\n",
    "                'nr_answers_mid': thread['nr_answers_mid'],\n",
    "                'nr_answers_low': thread['nr_answers_low'],\n",
    "                'nr_answers_unknow': thread['nr_answers_unknow']\n",
    "            })\n",
    "        \n",
    "    df = pd.DataFrame.from_dict(threads_quality, orient='index')\n",
    "    \n",
    "\n",
    "    \n",
    "    df_summed = df.groupby('question_quality').sum()\n",
    "    df_tot = df_summed.sum(axis='columns')\n",
    "    df_divided = df_summed.divide(df_tot, axis='index') * 100\n",
    "    #df_final = df_divided.append(df_tot / df_tot * 100, ignore_index=True)\n",
    "    \n",
    " \n",
    "    question_qual_vs_ans_qual[db] = df_divided"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": [
    "fields_list = list(reversed(['nr_answers_unknow','nr_answers_low', 'nr_answers_mid', 'nr_answers_high']))\n",
    "\n",
    "\n",
    "fig = plt.figure(figsize=(15, 6))\n",
    "fig.suptitle(\"Questions quality vs Answers quality (%)\", fontsize=18)\n",
    "\n",
    "ax1 = fig.add_subplot(131)\n",
    "sns.heatmap(question_qual_vs_ans_qual['cooking'][fields_list], annot=True, fmt = '.0f', cbar=False, ax=ax1)\n",
    "for t in ax1.texts: t.set_text(t.get_text() + \"%\")\n",
    "plt.ylabel('Questions quality', fontsize=18)\n",
    "plt.xlabel('Answers quality', fontsize=18)\n",
    "plt.title('cooking', fontsize=18)\n",
    "\n",
    "ax2 = fig.add_subplot(132,  sharey=ax1, sharex=ax1)\n",
    "sns.heatmap(question_qual_vs_ans_qual['travel'][fields_list], annot=True, fmt = '.0f', cbar=False, ax=ax2)\n",
    "for t in ax2.texts: t.set_text(t.get_text() + \"%\")\n",
    "plt.ylabel('Questions quality', fontsize=18)\n",
    "plt.xlabel('Answers quality', fontsize=18)\n",
    "plt.title('travel', fontsize=18)\n",
    "\n",
    "ax3 = fig.add_subplot(133,  sharey=ax1, sharex=ax1)\n",
    "sns.heatmap(question_qual_vs_ans_qual['webapps'][fields_list], annot=True, fmt = '.0f', cbar=False, ax=ax3)\n",
    "for t in ax3.texts: t.set_text(t.get_text() + \"%\")\n",
    "plt.ylabel('Questions quality', fontsize=18)\n",
    "plt.xlabel('Answers quality', fontsize=18)\n",
    "plt.title('webapps', fontsize=18)\n",
    "\n",
    "plt.tight_layout(pad=3)\n",
    "\n",
    "for plot_format in PLOTS_FORMATS: \n",
    "    plt.savefig(PLOTS_PATH + 'questions_quality_VS_answers_quality' + plot_format)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true,
    "deletable": true,
    "editable": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
